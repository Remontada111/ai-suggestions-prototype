    raw = resp.choices[0].message.content or "{}"
    try:
        out = json.loads(raw)
    except Exception as e:
        raise HTTPException(500, f"Modellen returnerade ogiltig JSON: {e}")

    mode = out.get("mode")
    target_rel = cast(str, out.get("target_path") or "")
    mount = out.get("mount") or {}
    file_code = out.get("file_code") or ""
    unified_diff = out.get("unified_diff") or ""

    if not mode or not target_rel:
        raise HTTPException(500, "Saknar 'mode' eller 'target_path' i modelsvaret.")

    # 5) Git branch
    branch = unique_branch(node_id)
    repo.git.checkout("-b", branch)

    # 6) Tillämpa ändring
    #    - file: skriv fil under TARGET_COMPONENT_DIR
    #    - patch: git apply, men om målet är main.tsx → ignorera diff och använd AST-injektion
    returned_path: str
    if mode == "file":
        target_rel = _normalize_target_for_file_mode(target_rel)
        target_path = tmp_root / target_rel
        target_path.parent.mkdir(parents=True, exist_ok=True)
        if not file_code:
            raise HTTPException(500, "file_code saknas för mode='file'.")
        target_path.write_text(file_code, encoding="utf-8")
        returned_path = target_rel

    elif mode == "patch":
        norm = target_rel.replace("\\", "/")
        if norm not in ALLOW_PATCH:
            raise HTTPException(400, f"Patch ej tillåten för {norm}. Tillåtna: {ALLOW_PATCH}")
        # Om modellen försöker patcha main.tsx: ignorera diff och låt AST-injektion hantera mount.
        if norm.endswith("main.tsx"):
            logger.info("Ignorerar diff mot main.tsx; använder AST-injektion för montering.")
            returned_path = norm  # vi returnerar main.tsx-innehåll efter AST för editor-apply
        else:
            if not unified_diff:
                raise HTTPException(500, "unified_diff saknas för mode='patch'.")
            _git_apply(tmp_root, unified_diff)
            returned_path = norm
    else:
        raise HTTPException(500, f"Okänt mode: {mode}")

    # 7) AST-injektion för mount (alltid)
    _ast_inject_mount(tmp_root, mount)

    # 8) Typecheck + lint
    _typecheck_and_lint(tmp_root)

    # 9) Commit
    #    Stage både target-filen och main.tsx om den ändrats.
    repo.git.add("--all")
    commit_msg = (
        f"feat(ai): add {returned_path}" if mode == "file" else f"chore(ai): patch {returned_path}"
    )
    repo.index.commit(commit_msg)
    logger.info("Commit klar: %s", commit_msg)

    # 10) Läs ut filinnehåll som ska skickas tillbaka till extension
    #     Om vi valde att returnera main.tsx, läs den. Annars läs målfilen.
    out_path = tmp_root / returned_path
    if not out_path.exists():
        # Om modellen skapade fil + vi samtidigt returnerar main.tsx
        # kan returned_path peka på main.tsx. Då finns den.
        raise HTTPException(500, f"Returnfil saknas: {returned_path}")

    content = out_path.read_text(encoding="utf-8")
    logger.info("Code changes ready for direct apply: %s", returned_path)
    return {"content": content, "path": returned_path}

# Registrera ev. analyze-tasks
try:
    from . import analyze as _register_analyze  # noqa: F401
except Exception as e:  # pragma: no cover
    logging.getLogger(__name__).warning("Kunde inte importera analyze-tasks: %s", e)

__all__ = ["app", "celery_app", "integrate_figma_node"]
